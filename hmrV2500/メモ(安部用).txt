忘備録

・　設計思想を意識する
・　依存関係をできるだけ減らしているのであればそれに従うべき




dx関連描画関数について
　os クラスは静的に用意する
　それ以外は動的に定義

draw関数の中でコネクションは使ってはいけない

ユニークコネクションは1つのクラスに対し、すべての接続を管理できる
　さらに、接続もやってくれる
　
オブジェクト同士の接続は、接続関数を用意して、一つのオブジェクトに対して接続を作る
　引数１が引数２と接続する　という流れで接続

できるだけ、使う側の視点に立つようにする！！


signal slot の関数名について

 signal : 基本的に自分のやったこと（ボタン押されたよー　みたいな）を変数名にしておく
 slot   : 自分のやることを関数名にする
 		　ここで、set  : データの変更を要求する(データの管理者にデータを変更させるということ)
		　		　sync : データの変更の確認を行う(変更されましたよor変更されてないというのを、情報伝達役のものに伝える）



2013.4.20
signal, slot の仕様変更

signal のメリットは、あらゆるところで起こったイベントを、一つのスロットに教えることができる点
inquirely のメリットは、データを簡単に参照(コピー)して共有できる点。

いま、ボタンを作るときに、変数を同期するためにわざわざ、ボタン押されたこと伝えて（UI::signal -> Ctr::slot）、変更されたことを同期する（Ctr::signal -> UI::slot） ということをしていたが、
わざわざデータを同期するのが馬鹿らしい。
結局、ボタンのフラグはCtr側で1か所で管理できるはずで、それを、UI側で

UI::signal -> Ctr::slot
UI::inquire -> Ctr::contact

という形で実行すれば、完全に描画側が、変数の管理の責任を負わなくて済むことになる。


基本的に
 signal  :: 様々な場所で起こるであろうイベント　(同じイベントが異なる場所で起こる可能性があるもの)  
	　　能動的でなければならないか
 slot    :: イベントに対しての処理
 inquire :: こちらから、たとえば、データ、状態のようなものを能動的に要求したい場合　(管理者のデータをもらうとか)
 contact :: 基本的に固定されているであろう変数　（フラグ、データなど、管理者が保持しているデータ）


2013.4.27
例外処理について
assert で　例外の型を指定することができるようになった

2013.5.11

全二重、半二重通信について
　Operator側ですべて管理することにする
　TimeOutも管理する
　VMCからデータの終了、開始などを受け取り、こちらですべてを制御。
　
　IO側はInquirely によって必要な情報をOperatorから受け取る形にする


バッファ管理について
　現在、待機バッファが一切存在しないので、待機用のバッファを創設する　
　hmrLib::BufCtrをラッピングする形で対応する。

2013.5.19

座標変換について
　一通り実装した。

基本的に後はすべてつなげばOK


ただ、少し考えとくべき点
hmrOperator 
　こいつは、VMCがうまくいってないことを感知して、きちんとそれに対処する必要がある
　TimeOutでパケットが受信完了しなければ、VMCの受信を強制終了する措置をとる

　TimeOut と TimeInterval の考え方

　　　VMCはsignalによって、パケットの受信終了を知らせ続ける。
　　　その受信終了時刻を記録しておいて、

　　　全二重において
　　　　とりあえず、TimeIntervalで送信して、いつでも受信を行う。　　　　
　　　　最新の受信終了時刻からTimeOutを過ぎてしまったときに、VMCの受信フェーズを強制終了する。

　　　半二重において
　　　　最新の受信終了時刻から、TimeInterval待って送信する。(Intervalを0にするとsyncということ)
　　　　最新の受信終了時刻からTimeOutを過ぎてしまったときに、VMCの受信フェーズを強制終了する。
　
　　
hmrCom 
  VMCの状況を報告する。
　VMCのリセット機能を提供しておく

hmrIO 
  VMCの要求通りに何も考えず動けばよい
　臨時送信だけは受け付けてあげる。
　この臨時送信は、VMCにはお伺いは立てずにIOの責任で送信する。VMC通さないのだから、VMCの状況によらずに送信できたほうがよいだろう。　　


2013.5.25

責任について
　クラスの責任をどう設計するか？？
　　ユーザーに対して何の責任を負っているかということ
　　
	hmrIO : VMCの要求にこたえる。送れと言われたら送るし、くれと言われたらあげる
　　　　	一方で、ゲートの送信受信も使役しているので、VMC以外からの要求をかなえることもできる
　　　　	
	hmrCOM: VMCの中で行う処理を決める。
			そして、OPにデータの受信送信インターフェースを与える			
	
	hmrOperator: 通信を制御する
	


MainUIの整理
　IOside, IoMain, 他のもつなげてしまう　hmrDxMUI
　
TestPadを見ながらKeyをつなぐ
　Connectで書いていく感じ

2013.6.2

やったこと
　UI系をひとまとまりにした。
　Key系をつないだ
　デバッグ開始　
　　カメラについてのチェックが残っている
　　　take pic が来てそうではあるが・・・不明
　　それ以外はうまくいっている
　
問題
　hmrDxDisplay系が更新されてなかったのでは？？　途中のままだった
　hmrDxCom　の　376行目などの　std::equal_range　で　iterator に不具合が起きた問いうエラーが出る　−＞　対処はできそうだが原因不明
　カメラは1つ壊れたか？　
　　　　

// Inquirely　の　注意
inquiry<A> Inq;

auto begin = Inq().data.Begin()
auto end = Inq().data.End()

for(auto i = begin; i < end;i++){
  brabrabra
}

はエラーが出る。
なぜなら、Inq()はコピーの値を返すので、Inq().data.Begin()　と　Inq().data.End()　のアドレスは異なるのだから。。。

inquiry<A&>みたいにすればOK, あるいは一時変数に入れてしまうか。


6月15日　ログ
　OperatorのSUIが途中、これを書き終えれば、すべてコネクトしてみる
　Operatorのどの情報を与えるか、特にタイムアウトがかかったかどうかについては次回かきかきする


7月5日
　Draw - Data - Message Agent
　のつなぎのところで、それぞれの役割
　
　Draw : 何かデータをもらってそれを描画する　
　Agent: 文字列データをわかる形のデータ(double)とかに変換する 
  Data : この2つの橋渡しを行うためのデータの整形を行う
　　　　　こいつがすべて2つの間の齟齬を取り除いてくれる。ほかの2つは適当に変えてもここを変えることだけで対応できる。　

7月20日
　Fileクラスの実装中
　コネクト関数が途中なのと、sprite関数を実装する必要がある
　あとseparator という名前に変えたほうがよいだろう
　
8月3日
　GPS　CH　変更コマンドを受け付けない

9月7日
　File系実装。ところどころにバグを発見修正

　疑問
　　JPEGファイルを作る際に、カメラからのデータをそのまま垂れ流ししてしまうと、ファイルが壊れていると主張してくる。
　　何か細かい変えておく所があったんやったっけ？？
     -> ファイルをバイナリで保存する必要がある
　　
　　ファイルをフォルダに入れる際に、どのような関数を使うべきか？

　　GPS系にまだバグが残っている可能性がある

9月14日
　FILE系の実装完了
　GPSのバグ修正に移っていく


  見つかったバグ
　　EXEファイルでV2500_v1_04 を実行したときに、64bit PC(Maple THinkPad)で実行すると、MUIのH2Sの部分に　"000000000・・・・・"　と出てきてしまう。
　　ただ、32ビットPC(Sirocco jasmin) ではこの現象は起こらない。
　　さらには、release のEXEではこの現象が起きるが、DEBUGではこの現象が起きない。
　原因
　　64bitと32bitにおけるライブラリ関連の相違が問題なのかな？？
　　原因は特定できていない。。。


  通信のバグについて
　　PIC視点で見たときに、受信なしで送信するのみであれば問題はおきない(無限ループに陥らない)(30分程度)
　　次に、受信ありでも、#ctr## cr lf のみの送信であれば問題は起きない
　　しかし、送信の中身が存在してしまうと(この場合！の文字列)、途中でPICが返答を一切しなくなってしまう。(25分後、10分後、まちまち)

　　送信の中身が存在した状態で受信割り込みが起きた時に、何が起こるか考えてみる


Task 

TaskFunc    sint16 func_task(sint16 ms)
 		戻り値で次にタスクが呼ばれる時間を決める
		外部からはリスタートで制御できる

TaskMaster　TaskFuncを管理する
		TaskMaster_inform(sint16, sint16)		


10月12日

無限ループはどこで起きているか

　while(PIC の　フラグ)的なところでループになる

　mallocのところでループになるわけではない
　
　間違い
　　Heap領域の確保に失敗して無限ループになっている？？
　　マルロック関連で、フリーを二回するとかのバグでループになっている？？



バグの原因についての予測。
　
１、なぜかVMCの中で行うとエラーが出るが、その外でマルロック・フリー行うとエラーは出ない。割り込み中でも問題なし。

２、送信フェーズで、送信データにかかわる処理、データぶち込むとかetcをのぞいたら、
	VMC内でマルロックしていても、そのようなエラーは出ない
	

仮説
　１、VMC内でマルロックするのと、外でするのとの違いは単純に処理時間だったりするのか？？

　２、深い階層の関数内でマルロックするとだめなのか？？


クリティカルの処理に問題が
　　


hmrDeviceManageを製作中
残っている点
　１、ローミングの実装
　２、パワー系の実装



10月19日

M2500 で　Sleep関数にバグがあるか？？

状況
　・スリープモードに入って復帰したのち、バッテリーを要求しても、データ送信モード(0x10)になったというインフォームシグナルは来るが、
　　そのあとにデータは一切こない。何度やっても同じ状態が起こる。
　・GPSについても同じ状況がおこる。この場合は、インフォームシグナルと同時にゴミも送られてくる
  ・アクセルとかジャイロについては、コマンドを送ると返信がなくなる。I2C系のモジュールで無限ループに入っているか(タイマ割り込みは無事である)

考えられる原因
　まず、セットアップトーク、送るところのif文にキチンと入っているかとかから確認していくのがよいのか
　Task のところで処理ができていないことが問題。
　Task関数によって、定期的にデータの更新が行われているので、Normalになったとしても、そことの接続がうまくいってないのが問題　

10月26日

M2500でSleep後に復帰できない（送信のみが行われないバグがある）
割り込み関数をいじったことが問題だと思うので、そこらへんを次回洗い出す必要がある


大島に向けてやること

プログラム作成
　スリープモード
　携帯からの電源投入
　センサ系のチェック(積むセンサについて)
　
ハード
　天板作成
　ライトの挿入場所の工作
　予備のコネクタ配線類の調達



消耗品のチェック
　
　

もしかして
　車輪の制作？？









































 Task Master　
　